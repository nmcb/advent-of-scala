package aoc

object Day05 {

  val program: Seq[Int] = 
    Seq(3,225,1,225,6,6,1100,1,238,225,104,0,1101,65,39,225,2,14,169,224,101,-2340,224,224,4,224,1002,223,8,223,101,7,224,224,1,224,223,223,1001,144,70,224,101,-96,224,224,4,224,1002,223,8,223,1001,224,2,224,1,223,224,223,1101,92,65,225,1102,42,8,225,1002,61,84,224,101,-7728,224,224,4,224,102,8,223,223,1001,224,5,224,1,223,224,223,1102,67,73,224,1001,224,-4891,224,4,224,102,8,223,223,101,4,224,224,1,224,223,223,1102,54,12,225,102,67,114,224,101,-804,224,224,4,224,102,8,223,223,1001,224,3,224,1,224,223,223,1101,19,79,225,1101,62,26,225,101,57,139,224,1001,224,-76,224,4,224,1002,223,8,223,1001,224,2,224,1,224,223,223,1102,60,47,225,1101,20,62,225,1101,47,44,224,1001,224,-91,224,4,224,1002,223,8,223,101,2,224,224,1,224,223,223,1,66,174,224,101,-70,224,224,4,224,102,8,223,223,1001,224,6,224,1,223,224,223,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,108,226,226,224,102,2,223,223,1005,224,329,101,1,223,223,1107,226,677,224,1002,223,2,223,1005,224,344,101,1,223,223,8,226,677,224,102,2,223,223,1006,224,359,101,1,223,223,108,677,677,224,1002,223,2,223,1005,224,374,1001,223,1,223,1108,226,677,224,1002,223,2,223,1005,224,389,101,1,223,223,1007,677,677,224,1002,223,2,223,1006,224,404,1001,223,1,223,1108,677,677,224,102,2,223,223,1006,224,419,1001,223,1,223,1008,226,677,224,102,2,223,223,1005,224,434,101,1,223,223,107,677,677,224,102,2,223,223,1006,224,449,1001,223,1,223,1007,226,677,224,102,2,223,223,1005,224,464,101,1,223,223,7,677,226,224,102,2,223,223,1005,224,479,101,1,223,223,1007,226,226,224,102,2,223,223,1005,224,494,101,1,223,223,7,677,677,224,102,2,223,223,1006,224,509,101,1,223,223,1008,677,677,224,1002,223,2,223,1006,224,524,1001,223,1,223,108,226,677,224,1002,223,2,223,1006,224,539,101,1,223,223,8,226,226,224,102,2,223,223,1006,224,554,101,1,223,223,8,677,226,224,102,2,223,223,1005,224,569,1001,223,1,223,1108,677,226,224,1002,223,2,223,1006,224,584,101,1,223,223,1107,677,226,224,1002,223,2,223,1005,224,599,101,1,223,223,107,226,226,224,102,2,223,223,1006,224,614,1001,223,1,223,7,226,677,224,102,2,223,223,1005,224,629,1001,223,1,223,107,677,226,224,1002,223,2,223,1005,224,644,1001,223,1,223,1107,677,677,224,102,2,223,223,1006,224,659,101,1,223,223,1008,226,226,224,1002,223,2,223,1006,224,674,1001,223,1,223,4,223,99,226)

  // Part 1
  sealed trait Mode
  case object IM extends Mode
  case object PM extends Mode
  type Modes = (Mode, Mode, Mode)
  case class Op(code: Int, modes: Modes)
  object Op {
    def mode(i: Int): Mode =
      if (i == 0) PM else if (i == 1) IM else sys.error("boom")

    def fromInt(i: Int): Op = {
      val code = i % 100
      val p1   = (i / 100) % 10
      val p2   = (i / 1000) % 10
      val p3   = (i / 10000) % 10
      Op(code, (mode(p1), mode(p2), mode(p3)))
    }
  }

  assert(Op.fromInt(1)     == Op(1,  (PM, PM, PM)))
  assert(Op.fromInt(2)     == Op(2,  (PM, PM, PM)))
  assert(Op.fromInt(3)     == Op(3,  (PM, PM, PM)))
  assert(Op.fromInt(4)     == Op(4,  (PM, PM, PM)))
  assert(Op.fromInt(99)    == Op(99, (PM, PM, PM)))
  assert(Op.fromInt(101)   == Op(1,  (IM, PM, PM)))
  assert(Op.fromInt(1002)  == Op(2,  (PM, IM, PM)))
  assert(Op.fromInt(11002) == Op(2,  (PM, IM, IM)))

  def interpret(prog: Seq[Int], i: Int = 0): Int = {

    def op: Op  = Op.fromInt(prog(i))
    def v1: Int = if (op.modes._1 == PM) prog(prog(i+1)) else prog(i+1)
    def v2: Int = if (op.modes._2 == PM) prog(prog(i+2)) else prog(i+2)
    def v3: Int = if (op.modes._3 == PM) prog(prog(i+3)) else prog(i+3)

    def calc(f: (Int, Int) => Int): Seq[Int] =
      prog.updated(prog(i+3), f(v1, v2))

    def read(): Seq[Int] =
      print("?> ") ; prog.updated(prog(i+1), scala.io.StdIn.readInt)

    def write(): Seq[Int] =
      println(s"!> ${v1}") ; prog

    def lt(): Seq[Int] =
      if (v1 < v2) prog.updated(prog(i+3), 1) else prog.updated(prog(i+3), 0)

    def eq(): Seq[Int] =
      if (v1 == v2) prog.updated(prog(i+3), 1) else prog.updated(prog(i+3), 0)
      
    op.code match {
      case 1  => interpret( calc(_+_) , i+4 )
      case 2  => interpret( calc(_*_) , i+4 )
      case 3  => interpret( read()    , i+2 )
      case 4  => interpret( write()   , i+2 )
      case 5  => if (v1 != 0)  interpret(prog, v2)  else interpret(prog, i+3)
      case 6  => if (v1 == 0)  interpret(prog, v2)  else interpret(prog, i+3)
      case 7  => interpret(lt(), i+4) 
      case 8  => interpret(eq(), i+4)
      case 99 => prog(0)
      case op: Int => throw new RuntimeException("Unknown opcode: " + op)
    }
  }

  assert(interpret(Seq(1,9,10,3,2,3,11,0,99,30,40,50)) == 3500)

  val result1: Int =
    interpret(program)
    
}